# Important Points

## init and exit macros
* In our driver we haven't used this macros because ours is a loadable module.
* This macros are mainly used for the static module (builtin module)
* The __init keyword tells the linker to place the code in a dedicated section into
  the kernel object file. This section is known in advance to the kernel, and freed
  when the module is loaded and the init function finished. This applies only to built-in drivers,
  not to loadable modules. The kernel will run the init function of the driver for the first
  time during its boot sequence.
* When __exit is used with a cleanup function, the kernel build system excludes those functions
  during the build process.  __exit acts as a marker for the build system to exclude cleanup functions
  from the final kernel image.


## Significance of the files created during the compilation
* Module.symvers contains a list of all exported symbols from a kernel build 
* .mod.c is a file that basically contains the information about the module (Version information etc.)
* built.in.o  This flag is not related to kernel modules but instead normal kernel build. Kbuild compiles 
  all the obj-y files. It then calls $(LD)-r to merge these files into one built-in.o file.
  built.in.o is later linked into vmlinux by the parent Makefile
* .mod.o object files resulting from the compilation of the .mod.c files
* .o object files resulting from the compilation of the module source files 
* modules.order In case you are compiling multiple modules together, it will list out the order in the compilation 
  and the creating of the .ko takes
* .ko the final kernel module binary that is loaded into the kernel
	
## Vermagic 
* Vermagic is a magic string present in the Linux Kernel and added into the . modinfo section
  of the Linux Kernel Modules. This is used to verify whether the kernel module was compiled for
  the particular kernel version or not. 'VERMAGIC_STRING' is generated by the kernel configuration.

## insmod module process

* calls init_module to hint the kernel that a module insertion is attempted
* Transfers controls to the kernel
* kernel executes sys_init_module
* Verifies Permissions
* load_module function is called
    * Checks the sanity of the .ko
    * Creates memory
	* Copies from user space to kernel space
	* Resolves symbols
	* Returns a reference to the kernel
* Adds the reference to a linked list that has all the loaded modules 
* module_init listed function

## rmmod module process

* rmmod calls delete_module() which hints the kernel that a module is to be removed 
    * control is transferred to the kernel
* kernel executes sys_delete_module()
    * Checks the permission of the one requesting
	* Checks if any other loaded module needs the current module
	* Checks if the module is actually loaded 
	* Executes the function provided in module_exit
	* free_module()
        * removes reference and kernel object reference
		* performs any other cleanup
		* Unloads the module
		* Changes the state in list
		* Removes it from the list and frees the memory

## Passing arguments to Linux Device Driver

### Module Parameters Macros

* module_param()
* module_param_array()
* module_param_cb()

#### module_param()

* This macro is used to initialize the arguments. Following is the syntax:
```
module_param(name, type, perm); //defined in linux/module_param.h
```
* This macro will create subdirectory under /sys/module. For example
```
module_param(valueETX, int, S_IWUSR|S_IRUSR);
/* This will create a sysfs entry in 
(/sys/module/hello_world_module/parameters/valueETX)*/
```

#### module_param_array()

* This macro is used to send the array as an argument to the Linux device driver.
  Array parameters, where the values are supplied as a comma-separated list, are also
  supported by the module loader. Following is the syntax:
```
module_param_array(name,type,num,perm);
```

#### module_param_cb()

* This macro is used to register the callback. Whenever the argument (parameter)
  got changed, this callback function will be called. This is mainly used to notify 
  the kernel, so that it will change any dependent operations related to this 
  parameter (like modifying the register setting data). This macro is defined as follows
```
module_param_cb(name, kernel_ops, arg, permission);
```
* If you want to get a notification whenever the value got to change, we need to register
  our handler function to its file operation structure first.
```
struct kernel_param_ops 
{
 int (*set)(const char *val, const struct kernel_param *kp);
 int (*get)(char *buffer, const struct kernel_param *kp);
 void (*free)(void *arg);
};
```

#### Permission flags

* S_IWUSR
* S_IRUSR
* S_IXUSR
* S_IRGRP
* S_IWGRP
* S_IXGRP

In this S_I is common and R=read , W=write, X=execute


## Major and Minor number

The major number and minor number tell the kernel how to access the device. A common major number
is assigned to all devices that are being controlled by the same device driver. The minor number
helps to distinguish between the exact device type/controller using the same device driver.
```
# Command used to create the entry manually in devfs
mknod /dev/file_entry c 254 0
```
* The combined major and minor cancatenated resides in the files i_rdev of the inode structure.
* dev_t and kdev_t are the data types declared to use hold the device numbers.

### Allocating Major and Minor numbers

1. Statically allocating
2. Dynamically allocating

#### Statically allocating
```
# Create the Major and Minor number using the MKDEV structure
MKDEV(int major,int minor)

# Individual functions to get the Major and Minor numbers
MAJOR(dev_t dev)
MINOR(dev_t dev)

# Register the char driver
int register_chrdev_region(dev_t first, unsigned int count, char *name);
```
* In the registering functions:
    * first is the beginning device number of the range you would like to allocate.
    * count is the total number of contiguous device numbers you are requesting.
    * name is the name of the device that should be associated with this number range; it will
      appear in /proc/devices and sysfs.
    * The return value from register_chrdev_region will be 0 if the allocation was successfully performed. 

**Example:**
```
dev_t dev = MKDEV(235, 0);

register_chrdev_region(dev, 1, "Embetronicx_Dev");
```

#### Dynamically allocating
```
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
```
* In the above function:
    * dev is an output-only parameter that will, on successful completion, hold the first number in your allocated range.
    * firstminor should be the requested first minor number to use; it is usually 0.
    * count is the total number of contiguous device numbers you are requesting.
    * name is the name of the device that should be associated with this number range; it will appear in /proc/devices and sysfs.

### Unregistering the Driver

```
void unregister_chrdev_region(dev_t first, unsigned int count);
```

## Creating the Device file

We can create the device file in two ways.
1. Manually
2. Automatically

### Manually Creating Device File

```
mknod -m <permissions> <name> <device type> <major> <minor>
Example:
    sudo mknod -m 666 /dev/etx_device c 246 0
```

### Automatically Creating the Device File

The automatic creation of device files can be handled by the udev. Udev is the device manager 
for the Linux kernel that creates/removes device node in the /dev directory dynamically. Just 
follow the below steps

1. Include the header file linux/device.h and linux/kdev_t.h
2. Create the struct Class
3. Create Device with the class which is created by the above step.

#### Create class

This will create the struct class for our device driver. It will create a structure under /sys/class/.

```
struct class * class_create(struct module *owner, const char *name);
* owner – pointer to the module that is to “own” this struct class
* name – pointer to a string for the name of this class
```

* This is used to create a struct class pointer that can then be used in calls to class_device_create.
  The return value can be checked using IS_ERR() macro.
* Note, the pointer created here is to be destroyed when finished by making a call to class_destroy.
```
void class_destroy (struct class * cls);
```

#### Create Device

This function can be used by char device classes. A struct device will be created in sysfs, and registered to the specified class.
```
struct device *device_create(struct *class, struct device *parent, dev_t dev, void * drvdata, const char *fmt, ...);

class – pointer to the struct class that this device should be registered to
parent – pointer to the parent struct device of this new device, if any
devt – the dev_t for the char device to be added
drvdata – the data to be added to the device for callbacks
fmt – string for the device’s name
... – variable arguments
```
Note, that you can destroy the device using device_destroy().
```
void device_destroy (struct class * class, dev_t devt);
```

## References
* [Linux Device Drivers 3](https://www.oreilly.com/library/view/understanding-the-linux/0596005652/apbs03.html#:~:text=A%20user%20can%20link%20a,in%20the%20system%20directory%20tree)
* [init and exit macros](https://fastbitlab.com/linux-device-driver-programming-lecture-18-__init-and-__exit-macros/)
* [init and exit macros ldd3](https://www.oreilly.com/library/view/linux-device-drivers/9781785280009/e636c201-5e6f-4ddb-a4b3-9bd72f71b9b0.xhtml)
