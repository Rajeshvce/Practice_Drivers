# Important Points

## init and exit macros
* In our driver we haven't used this macros because ours is a loadable module.
* This macros are mainly used for the static module (builtin module)
* The __init keyword tells the linker to place the code in a dedicated section into
  the kernel object file. This section is known in advance to the kernel, and freed
  when the module is loaded and the init function finished. This applies only to built-in drivers,
  not to loadable modules. The kernel will run the init function of the driver for the first
  time during its boot sequence.
* When __exit is used with a cleanup function, the kernel build system excludes those functions
  during the build process.  __exit acts as a marker for the build system to exclude cleanup functions
  from the final kernel image.


## Significance of the files created during the compilation
* Module.symvers contains a list of all exported symbols from a kernel build 
* .mod.c is a file that basically contains the information about the module (Version information etc.)
* built.in.o  This flag is not related to kernel modules but instead normal kernel build. Kbuild compiles 
  all the obj-y files. It then calls $(LD)-r to merge these files into one built-in.o file.
  built.in.o is later linked into vmlinux by the parent Makefile
* .mod.o object files resulting from the compilation of the .mod.c files
* .o object files resulting from the compilation of the module source files 
* modules.order In case you are compiling multiple modules together, it will list out the order in the compilation 
  and the creating of the .ko takes
* .ko the final kernel module binary that is loaded into the kernel
	
## Vermagic 
* Vermagic is a magic string present in the Linux Kernel and added into the . modinfo section
  of the Linux Kernel Modules. This is used to verify whether the kernel module was compiled for
  the particular kernel version or not. 'VERMAGIC_STRING' is generated by the kernel configuration.

## insmod module process

* calls init_module to hint the kernel that a module insertion is attempted
* Transfers controls to the kernel
* kernel executes sys_init_module
* Verifies Permissions
* load_module function is called
    * Checks the sanity of the .ko
    * Creates memory
	* Copies from user space to kernel space
	* Resolves symbols
	* Returns a reference to the kernel
* Adds the reference to a linked list that has all the loaded modules 
* module_init listed function

## rmmod module process

* rmmod calls delete_module() which hints the kernel that a module is to be removed 
    * control is transferred to the kernel
* kernel executes sys_delete_module()
    * Checks the permission of the one requesting
	* Checks if any other loaded module needs the current module
	* Checks if the module is actually loaded 
	* Executes the function provided in module_exit
	* free_module()
        * removes reference and kernel object reference
		* performs any other cleanup
		* Unloads the module
		* Changes the state in list
		* Removes it from the list and frees the memory

## References
* [Linux Device Drivers 3](https://www.oreilly.com/library/view/understanding-the-linux/0596005652/apbs03.html#:~:text=A%20user%20can%20link%20a,in%20the%20system%20directory%20tree)
* [init and exit macros](https://fastbitlab.com/linux-device-driver-programming-lecture-18-__init-and-__exit-macros/)
* [init and exit macros ldd3](https://www.oreilly.com/library/view/linux-device-drivers/9781785280009/e636c201-5e6f-4ddb-a4b3-9bd72f71b9b0.xhtml)
