# Interrupts

* interrupts    - asynchronous interrupts generated by the hardware
* Exceptions    - synchronous interrupts generated by the processor

## Types of interrupts

* Maskable - All Interrupt Requests (IRQ's) issued by the I/O devices give rise to maskable interrupts. A maskable interrupt can be in two states: masked or unmasked; a masked interrupt is ignored by the control unit as long as it remains masked. In simple maskable interrupts can be ignored by CPU.
* Non-maskable - Only a few critical events (such as hardware failures) give rise to nonmaskable interrupts. Non-maskable interrupts are always recognized by the CPU. In simple words non-maskable interrupts cannot be ignored by CPU

## Types of Exceptions

* Falts  - Like divison by zero, Page Fault, Segmentation Fault.
* Traps  - Reported immediately following the execution of the trapping instruction. Like Break points
* Aborts - Aborts are used to report severe errors, such as hardware failures and invalid or inconsistent values in system tables

## Interrupt Handler

An interrupt handler or interrupt service routine (ISR) is the function that the kernel runs in response to a specific interrupt:
1. Each device that generates the interrupt has an associated interrupt handler
2. The interrupt handler for a device is part of the device's driver  

In Linux, interrupt handlers are normal C functions, which match a specific prototype and thus enable the kernel to pass the handler information in a standard way. What differentiates interrupt handlers from other kernel functions is that the kernel invokes them in response to interrupts and that they run in a special context called interrupt context. This special context is occasionally called atomic context because code executing in this context is unable to block.

## Process context and interrupt context 

* Kernel code that services system calls issued by user applications runs on behalf of the corresponding application processes and is said to execute in the process context. Interrupt handlers, on the other hand, run asynchronously in the interrupt context.
* Kernel code running in process context is preemptible. An interrupt context, however is not preemptible.
* Code executing in the interrupt context cannot do the following:
    * Go to sleep or relenquish the processor
    * Acquire a mutex
    * Perform time-consuming tasks
    * Access user space virtual memory
* The processing of interrupts is split into two parts or halves:
    * Top halves
    * Bottom halves

### Top half

The interrupt handler is the top half. The top half will run immediately upon receipt of the interrupt and performs only the work that is time-critical, such as acknowledging receipt of the interrupt or resetting the hardware.

### Bottom half

The bottom half is used to process data, letting the top half to deal with new incoming interrupts. Interrupts are enabled when a bottom half runs. The interrupt can be disabled if necessary, but generally, this should be avoided as this goes against the basic purpose of having a bottom half â€“ processing data while listening to new interrupts. The bottom half runs in the future, at a more convenient time, with all interrupts enabled.

* There are 4 bottom half mechanisms are available in Linux:
    * Workqueue
    * Threaded IRQs
    * Softirq
    * Tasklets

## Points to be remembered for writing an Interrupt

* Interrupt handlers cannot enter sleep, so avoid calls to some functions which has sleep
* When the interrupt handler has part of the code to enter the critical section, use spinlocks lock, rather than mutexes. Because if it can't take mutex it will go to sleep untill it takes the mutex.
* Interrupts handlers cannot exchange data between the userspace.
* The interrupt handlers must be executed as soon as possible. To ensure this, it is best to split the implementation into two parts, the top half and bottom half. The top half of the handler will get the job done as soon as possible and then work late on the bottom half, which can be done with softirq or tasklets or workqueue.
* Interrupt handlers cannot be called repeatedly. When a handler is already executing it's corresponding IRQ must be disabled until the handler is done.
* Interrupt handlers can be interrupted by high authority handlers. If you want to avoid being interrupted by a high qualified handler, you can mark the interrupt handler as a fast handler. However, if too many are marked as fast handlers, the performance of the system will be degraded because the interrupt latency will be longer.

## Functions related to interrupt

### request_irq
```
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev_id);
```
Registers an IRQ, the parameter are as follows

* irq     - IRQ number to allocate
* handler - This is interrupt handler function. This function will be invoked whenever the operating system recevies the interrupt. The data type of return is irq_handler_t, if its return value is IRQ_HANDLED, it indicates that the processing of the interrupt is completed successfully, but if the return value is IRQ_NONE, the processing fails.
* flags   - can be either zero or a bit mask of one or more flags defined in linux/interrupt.h. The most important of these flags are    
    * IRQF_DISABLED
    * IRQF_SAMPLE_RANDOM
    * IRQF_SHARED
    * IRQF_TIMER 
* name    - used to identify the device name using this IRQ, for example cat /proc/interrupts will list the IRQ number and device name.
* dev_id  - IRQ shared by many devices. When an interrupt is freed, dev provides a unique cookie to enable the removal of only the desired interrupt handler from the interrupt line. Without this parameter, it would be impossible for the kernel  to know which handler to remove on a give interrupt line. You can pass the NULL here if the line is not shared, but you must pass a unique cookie if your interrupt line is shared. This pointer is also passed into the interrupt handler on each invocation. A common practice is to pass the driver's device structure. This pointer is unique and might be useful to have within the handlers.
* return  - returns zero on success and nonzero value indicates as error.

request_irq() cannot be called from interrupt context (other situations where code cannot block) because it can block.

### free_irq
```
free_irq(unsigned int irq, void *dev_id);
```
Release an IRQ registered by request_irq() with the following parameters:

* irq    -  IRQ number
* dev_id -  is the last parameter of the request_irq

If the specified interrupt line is not shared, this function removes the handler and disables the line. If the interrupt line is shared, the handler identified via dev_id is removed. With shared interrupt lines, a unique cookie is used to differentiate between the mutliple handlers that can exist on a single line and enable free_irq() to remove only the correct handler.
In either case (shared or unshared), if dev_id is non NULL, it must match the desired handler. A call to free_irq() must be made from process context.

### enable_irq
```
enable_irq(unsigned int irq)
```
Re-enable the interrupt disable the disable_irq or disable_irq_nosync

### disable_irq
```
disable_irq(unsigned int irq)
```
Disable an IRQ from issuing an interrupt.

### disable_irq_nosync
```
disable_irq_nosync(unsigned int irq)
```
Disable an IRQ from issuing an interrupt, but wait until there is an interrupt handler being executed.

### in_irq
```
in_irq();
```
Returns true when in interrupt handler

### in_interrupt
```
in_interrupt();
```
Returns true when in interrupt handler or bottom half

## Interrupt Flags

* IRQF_DISABLED
    * When set, this flag instructs the kernel to disable all interrupts when executing this interrupt handler. When unset, interrupthandlers run with all interrupts except their own enabled.
* IRQF_SAMPLE_RANDOM
    * This flag specifies that interrupts generated by this device should contribute to the kernel entropy pool. The kernel entropy pool provides truly random numbers derived from various random events. If this flag is specified, the timing of interrupts from this device is fed to the pool as entropy. Do not set this if your device issues interrupt at a predictable rate (e.g. the system timer) or can be influenced by external attackers (e.g. a networking device). On the other hand, most other hardware generates an interrupt at non-deterministic times and is, therefore, a good source of entropy.
* IRQF_TIMER
    * This flag specifies that this handler process interrupts the system timer.
* IRQF_SHARED
    * This flag specifies that the interrupt line can be shared among multiple interrupt handlers. Each handler registered on a given line must specify this flag; otherwise, only one handler can exist per line.

## Registering an Interrupt Handler
```
#define IRQ_NO 11

if (request_irq(IRQ_NO, irq_handler, IRQF_SHARED, "etx_device", (void *)(irq_handler))) {
            printk(KERN_INFO "my_device: cannot register IRQ ");
            goto irq;
}
```

## Freeing an Interrupt Handler
```
free_irq(IRQ_NO,(void *)(irq_handler));
```

## Interrupt Handler
```
static irqreturn_t irq_handler(int irq,void *dev_id) {
  printk(KERN_INFO "Shared IRQ: Interrupt Occurred");
  return IRQ_HANDLED;
}
```

## IDT and IDTR

### IDT 

The Interrupt Descriptor Table (IDT) is a data structure in x86 architecture that maps interrupt vectors to their corresponding interrupt handlers. It contains up to 256 entries, each defining how the CPU should handle a specific interrupt or exception, such as hardware interrupts, software interrupts, or CPU exceptions. The IDT is essential for managing system interrupts and ensuring the CPU can quickly locate and execute the appropriate handler when an interrupt occurs.

### IDTR

The Interrupt Descriptor Table Register (IDTR) is a special register in the CPU that tells the CPU where the Interrupt Descriptor Table (IDT) is located in memory and how big it is. It has two parts: the base address, which points to the start of the IDT, and the limit, which specifies the size of the IDT. When an interrupt occurs, the CPU uses the IDTR to find the IDT and determine how to handle the interrupt. The operating system sets up the IDTR during startup to ensure the CPU can manage interrupts correctly.
